# QnA

Describe in a high level the solution you have in mind
> - Count a user's most listened to genre
> - Match that genre's most listened to songs from:
>   i. People the user follow
>   ii. All users in the system
>
> Note: Please check JOURNAL.md for more thoughts on planned vs done

What other data could you use to improve recommendations?
> - Age = i.e: it's unlikely to recommend classical music to a teenager, or a rap song to an elderly person
> - Location = i.e: recommend trending songs in user's country
> - Tempo / BPM = i.e: user usually likes to listen to calming, downbeat songs
> - Time of the day = i.e: user usually likes to listen to calming, downbeat songs in the evening, and energetic, cheered up songs in the mornings; so depending on the time of the day, we would recommend something different.
> - Previously accepted recommendations = i.e: machine learning... Learn from experience which kind of recommendation the user accepted

Assume a more real world situation where you could have more data you described above, and more time to implement, could you think of a possibly more efficient way to recommend?
> I don't believe suggesting merely based on who the user follows is not very effective for I may be following my girlfriend just so I could every now and then send her a song we talked about or something like this, but wouldn't want to have automatic recommendations from her account for our musical taste is actually considerably different.
> So instead of recommendations only "because I follow her", it would probably be better to recommend based on possible genres or playlists we'd have in common.

Assume you have more than one implementation of recommendations, how could you test which one is more effective using data generated by user actions?
> As I stated above: a machine learning kind of thing: saving which recommendation the user has accepted in the past, also saving which "recommendation system" it came from (followed person, global trending songs, location based recommendations, etc).

--

How long did this assignment take?
> - One week and a half, approx. I had less than two hours each day and they were not contiguous. Had to shift back and forth with my other activities during the day.

Where would be the bottlenecks of this solution you have implemented?
> - For this MVP, every User operation will touch the database. In a more real world situation, I'd probably consider caching user information at least for some operations in order to avoid this costly I/O.
> - Every endpoint accepts only a single operation. For performance, I could make them accept an array of operations. E.g.: accept a bulk list of "follows".

What was the hardest part?
> - Sewing the new frameworks together with the tests
> - Troubleshooting incompatibilities (Monk promises are not pure ES2015 Promises, so I had to improvise and adapt little)
> - I'm not very good creating complex algorithms, data structures, so I'm never sure how good (if any) my solution is ;-)

Did you learn something new?
> - Koa.js
> - A little bit more of Promises and Generators
> - A little bit more of MongoDB
> - New tricks on testing with supertest + Koa.js or Express.js

Do you feel that your skills were well tested?
> - I think my JavaScript foo, code style and cleanness, git communication and organization, were well tested. This is what you can expect from me.
> But I believe what differentiates me the most is what it's not here: pro activeness, entrepreneurship, my taste to "peopleware", my leading and communication skills.
> Also I have other technical knowledge like great UI/UX taste, dev ops, automation, shell script, etc.
